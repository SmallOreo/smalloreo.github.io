<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>计算机科学导论第一章习题答案 | 奥利奥</title>
<link rel="shortcut icon" href="https://smalloreo.github.io/favicon.ico?v=1613468822649">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://smalloreo.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="计算机科学导论第一章习题答案 | 奥利奥 - Atom Feed" href="https://smalloreo.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="复习题[1]
1.定义一个基于图灵模型的计算机
一台可以输入/输出、使用相应程序处理任意需要计算的数据处理器
2.定义一个基于冯·诺依曼模型的计算机
计算机中拥有四个子系统，控制单元、输入/输出单元、存储单元、算术逻辑单元。其中程序和数据都..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://smalloreo.github.io">
  <img class="avatar" src="https://smalloreo.github.io/images/avatar.png?v=1613468822649" alt="">
  </a>
  <h1 class="site-title">
    奥利奥
  </h1>
  <p class="site-description">
    博学而笃志，厚积而薄发
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              计算机科学导论第一章习题答案
            </h2>
            <div class="post-info">
              <span>
                2021-02-14
              </span>
              <span>
                6 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="复习题">复习题<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h2>
<p><strong>1.定义一个基于图灵模型的计算机</strong><br>
一台可以输入/输出、使用相应程序处理任意需要计算的数据处理器</p>
<p><strong>2.定义一个基于冯·诺依曼模型的计算机</strong><br>
计算机中拥有四个子系统，控制单元、输入/输出单元、存储单元、算术逻辑单元。其中程序和数据都可以存储在存储单元中</p>
<p><strong>3.在基于图灵模型的计算机中，程序的作用是什么</strong><br>
程序是告诉计算机如何处理数据的一个指令集合</p>
<p><strong>4.在基于冯·诺依曼模型的计算机中，程序的作用是什么</strong><br>
在冯·诺依曼模型中规定程序必须存储在存储器中</p>
<p><strong>5.计算机中有哪些子系统？</strong><br>
控制单元，输入/输出单元，存储器，算术逻辑单元</p>
<p><strong>6.计算机中存储器子系统的功能是什么</strong><br>
存储数据和程序的单元</p>
<p><strong>7.计算机中的ALU子系统的功能是什么</strong><br>
提供计算和逻辑运算的单元</p>
<p><strong>8.计算机中控制单元的子系统的功能是什么</strong><br>
控制输入/输出、存储、算术逻辑单元</p>
<p><strong>9.计算机中输入/输出子系统的功能是什么</strong><br>
提供外部的输入和提供输出功能，可以提供输入/输出硬件有很多，如：硬盘，键盘，鼠标</p>
<p><strong>10.简述5个时代的计算机</strong><br>
第一代计算机只有专家才能使用，体积庞大，使用真空管<br>
第二代计算机使用了晶体管代替了真空管，体积减小，成本减少，中小型企业也可以使用<br>
第三代计算机使用集成电路，小型计算机出现，软件工程诞生<br>
第四代计算机出现微型计算机，第一个桌面计算机问世，计算机网络出现<br>
第五代计算机起始于1985年，还未结束，多媒体的应用，AR/VR的出现，台式计算机和笔记本电脑的实现，存储设备的升级等</p>
<h2 id="练习题">练习题</h2>
<p><strong>1.解释为什么计算机不能解决那些计算机外部世界无法解决的问题</strong><br>
计算机的处理数据的解决方案来自于程序，程序是由外部进行编写的。外部无法处理的问题也无法在计算机中解决</p>
<p><strong>2.如果一台小的便宜的计算机可以做大型昂贵的计算机同样能做的事情，为什么人们还需要大型计算机？</strong><br>
虽然小型计算机可以处理同样的问题，但是处理需要的时间可能不同。在同时代的大型计算机比小型计算机处理的更快，时间更短（PS：当然，科技的进步以后有可能会打破这样的限制）</p>
<p><strong>3.研究Pascaline计算机，看看它是否符合图灵模型</strong><br>
Pascsline只是能运行加减运算的计算器，不符合图灵模型</p>
<p><strong>4.研究莱布尼兹之轮（Leibnitz’s Wheel），看看它是否符合图灵模型</strong><br>
虽然莱布尼兹之轮能够进行更加复杂的运算，但是它没有程序的概念，不符合图灵模型</p>
<p><strong>5.研究雅卡尔提花织机（Jacquard loom），看看它是否符合图灵模型</strong><br>
雅卡尔提花织机利用穿孔卡（类似存储程序）来控制机器，拥有输出的经线提升的输出单元，读取穿孔卡的输入单元，所以它符合图灵模型</p>
<p><strong>6.研究查尔斯·巴比奇分析引擎，看看它是否符合冯·诺依曼模型</strong><br>
查尔斯·巴比奇分析引擎虽然拥有类似冯·诺依曼模型的四个子系统，但是程序无法存储在存储器中，所以不符合冯·诺依曼模型</p>
<p><strong>7.研究ABC计算机，看看它是否符合冯·诺依曼模型</strong><br>
ABC计算机并没有将程序存储在存储器中，计算机是在外部编程的，所以不符合冯·诺依曼模型</p>
<p><strong>8.研究并找出键盘起源于哪一代计算机</strong><br>
计算机键盘出现在第二代计算机末期，第三代初期(第一个键盘与多用户系统均在1964出现，也就是在第二代计算机末期和第三代计算机初期出现)</p>
<h2 id="附加选择">附加选择</h2>
<p>11.现在的计算机是基于_____模型。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
<p>12.在计算机中，_____子系统存储数据和程序。<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p>
<p>13.在计算机中，_____子系统执行计算和逻辑运算。<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p>
<p>14.在计算机中，_____子系统接收数据和程序并将运算传给输出设备。<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></p>
<p>15.在计算机中，_____子系统是其他子系统的管理者。<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup></p>
<p>16.根据冯·诺伊曼模型，_____被存在存储器中。<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup></p>
<p>17.问题的分步骤解决被称为_____。<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup></p>
<p>18.FORTRAN和COBOL是_____的例子。<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup></p>
<p>19.在17世纪能执行加法和减法运算的计算机器是______. <sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup></p>
<p>20.在计算机语言中，______是告诉计算机如何处理数据的一系列指令。<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup></p>
<p>21.______是以结构化的形式来设计和编写程序。<sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup></p>
<p>22.第一台特殊用途的电子计算机被称为______. <sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup></p>
<p>23.第一代基于冯·诺伊曼模型的计算机有一个被称为______. <sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup></p>
<p>24.第一台使用存储和编程的计算机被称为______. <sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup></p>
<p>25.______将程序设计任务从计算机运算任务中分离出来。<sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>本答案及附加题均转载自CSDN <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>b.冯·诺伊曼 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>c.存储器 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>a.算术逻辑单元（ALU） <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>b.输入/输出 <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>d,控制单元 <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>c.数据和程序 <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>d.算法 <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>c.计算机语言 <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>a.Pascaline <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>d.程序 <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>a.软件工程 <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>c.ABC <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>d.EDVAC <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>d.the Jacquard loom <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>c.高级程序设计语言 <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%A4%8D%E4%B9%A0%E9%A2%98">复习题[^CSDN]</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0%E9%A2%98">练习题</a></li>
<li><a href="#%E9%99%84%E5%8A%A0%E9%80%89%E6%8B%A9">附加选择</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://smalloreo.github.io/dui-yi-ge-cheng-xu-mian-shi-ti-de-ge-ren-li-jie/">
              <h3 class="post-title">
                对一个程序（面试题）的个人理解【C#】
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '5f5eeddcb9f3a146ff9c',
    clientSecret: '9b4da3df4fbb5148a28c7249f1a0825200343367',
    repo: 'smalloreo.github.io',
    owner: 'smalloreo',
    admin: ['smalloreo'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  小简奥利奥好吃吗？
  <a class="rss" href="https://smalloreo.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
